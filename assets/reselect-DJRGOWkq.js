function C(e,o=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(o)}function M(e,o=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(o)}function k(e,o="expected all items to be functions, instead received the following types: "){if(!e.every(r=>typeof r=="function")){const r=e.map(s=>typeof s=="function"?`function ${s.name||"unnamed"}()`:typeof s).join(", ");throw new TypeError(`${o}[${r}]`)}}var j=e=>Array.isArray(e)?e:[e];function T(e){const o=Array.isArray(e[0])?e[0]:e;return k(o,"createSelector expects all input-selectors to be functions, but received the following types: "),o}function A(e,o){const r=[],{length:s}=e;for(let t=0;t<s;t++)r.push(e[t].apply(null,o));return r}var E=class{constructor(e){this.value=e}deref(){return this.value}},S=typeof WeakRef<"u"?WeakRef:E,W=0,z=1;function g(){return{s:W,v:void 0,o:null,p:null}}function h(e,o={}){let r=g();const{resultEqualityCheck:s}=o;let t,u=0;function i(){var m;let n=r;const{length:d}=arguments;for(let a=0,v=d;a<v;a++){const f=arguments[a];if(typeof f=="function"||typeof f=="object"&&f!==null){let l=n.o;l===null&&(n.o=l=new WeakMap);const y=l.get(f);y===void 0?(n=g(),l.set(f,n)):n=y}else{let l=n.p;l===null&&(n.p=l=new Map);const y=l.get(f);y===void 0?(n=g(),l.set(f,n)):n=y}}const p=n;let c;if(n.s===z?c=n.v:(c=e.apply(null,arguments),u++),p.s=z,s){const a=((m=t==null?void 0:t.deref)==null?void 0:m.call(t))??t;a!=null&&s(a,c)&&(c=a,u!==0&&u--),t=typeof c=="object"&&c!==null||typeof c=="function"?new S(c):c}return p.v=c,c}return i.clearCache=()=>{r=g(),i.resetResultsCount()},i.resultsCount=()=>u,i.resetResultsCount=()=>{u=0},i}function R(e,...o){const r=typeof e=="function"?{memoize:e,memoizeOptions:o}:e,s=(...t)=>{let u=0,i=0,n,d={},p=t.pop();typeof p=="object"&&(d=p,p=t.pop()),C(p,`createSelector expects an output function after the inputs, but received: [${typeof p}]`);const c={...r,...d},{memoize:m,memoizeOptions:a=[],argsMemoize:v=h,argsMemoizeOptions:f=[],devModeChecks:l={}}=c,y=j(a),x=j(f),b=T(t),w=m(function(){return u++,p.apply(null,arguments)},...y),O=v(function(){i++;const $=A(b,arguments);return n=w.apply(null,$),n},...x);return Object.assign(O,{resultFunc:p,memoizedResultFunc:w,dependencies:b,dependencyRecomputations:()=>i,resetDependencyRecomputations:()=>{i=0},lastResult:()=>n,recomputations:()=>u,resetRecomputations:()=>{u=0},memoize:m,argsMemoize:v})};return Object.assign(s,{withTypes:()=>s}),s}var D=R(h),F=Object.assign((e,o=D)=>{M(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const r=Object.keys(e),s=r.map(t=>e[t]);return o(s,(...t)=>t.reduce((u,i,n)=>(u[r[n]]=i,u),{}))},{withTypes:()=>F});export{R as c,h as w};
